#!/usr/bin/perl
use strict;
use warnings;
use POSIX;
use Data::Dumper;
use Getopt::Long;
use Time::HiRes qw(usleep);
use Fcntl qw(:flock SEEK_END);

# Turn on autoflush
$|++;

# Lengths in base pairs, ideal values depend on sequencing strategy
my $min_exon_length = 10;
#my $min_misaligned_intron_length = 100;
my $min_misaligned_intron_length = 30;
#my $min_overhang_length = 40;
my $min_overhang_length = 50;
my $max_overhang_length = 500; # not used yet
#my $max_overhang_length = 200; # not used yet
my $min_overhang_length_discrepancy = 10; # not used yet

# We want to multithread when we can
my $free_cpus = &get_free_cpus;

# Check that required executables are in path
my $blat = check_path_for_exec("blat");
my $mafft = check_path_for_exec("mafft");
my $spaln = check_path_for_exec("spaln");

# Parse command line invocation
my $targets;
GetOptions(
	't|targets=s' => \$targets,
);

my $input = shift;

# Input error checking
die "You must specify an assembly as input.\n" if (!defined($input));
die "You must specify a fasta file containing target sequences (-t).\n" if (!defined($targets));
die "You must you have specified an incorrect argument.\n" if (@ARGV);

# Output file names
my $blat_out_name = $input.".psl";
(my $consensus_output = $input) =~ s/\.fa(sta)?/.con.fasta/i;

# Run preliminary blat to determine which targets and contigs have alignable sequence
print "Running blat against targets and contigs...\n";
my $return = system("$blat $input $targets -t=dna -q=dna -noHead -repMatch=1000000 $blat_out_name") if (!-e $blat_out_name);
die "Error running blat: '$return'.\n" if ($return);
print "Blat completed, parsing hits...\n";

# Parse blat output
my %targets;
open(my $blat_out, "<", $blat_out_name);
while (my $line = <$blat_out>) {
	chomp($line);

	my @line = split(/\s+/, $line);

	# Blat headers
	my ($match, $mismatch, $rep_matches, $n_count, $q_num_inserts, $q_base_inserts, 
	    $t_num_inserts, $t_base_inserts, $strand, $q_name, $q_size, $q_start, $q_end,
		$t_name, $t_size, $t_start, $t_end, $block_count, $block_sizes, $q_starts, $t_starts) = @line; 

	# TODO: make this not stupid
	$targets{$q_name}->{$t_name} = {'NAME' => $t_name};
}
close($blat_out);
print "Hits successfully parsed.\n";

# Load contig and target sequences
my %contig_seqs = parse_fasta($input);
my %target_seqs = parse_fasta($targets);

# Create consensus sequence for each target
my %troublesome;
my %final_alignments;
foreach my $target (keys %targets) {
	# list of defeated troublesome contigs
	#$target = '161|Gorai.012G146100.2|';
	#$target = '596|Gorai.006G215300.1|';
	#$target = '959|Gorai.001G017000.1|';
	#$target = '11792|Gorai.007G202700.5|';
	#$target = '13902|Gorai.011G084700.1|';
	#$target = '8547|Gorai.003G086700.1|';
	#$target = '1984|Gorai.001G079800.1|';
	#$target = '7115|Gorai.005G200400.1|';

	my @hits = values %{$targets{$target}};
	my $target_seq = $target_seqs{$target};

	print "\nAligning the following contigs to target '$target':\n";

	# Stores locations and sequences of introns
	my %introns;
	my %potential_introns = {START => {}, END => {}};
	$final_alignments{$target}->{$target} = $target_seq;

	# Use spaln to align exons of each contig with the reference and identify introns
	foreach my $hit (@hits) {
		my $seqname = $hit->{'NAME'};
		my $seq = $contig_seqs{$seqname};

		print "  $seqname\n";

		# Perform alignment with spaln
		align_contig({CONTIG_NAME => $seqname, 
		              CONTIG_SEQ => $seq, 
					  TARGET_NAME => $target, 
					  TARGET_SEQ => $target_seq, 
					  INTRONS => \%introns,
					  POT_INTRONS => \%potential_introns});
	}

	# Think remove_intron_from_exon needs to be run first?
	#insert_potential_introns(\%potential_introns, $target, $target_seq);
	#insert_potential_introns(\%introns, \%potential_introns, $target, $target_seq);
	#die;
	#print Dumper(\%potential_introns),"\n";
	#die;

	move_misaligned_introns(\%introns, $target, $target_seq);
	insert_potential_introns(\%introns, \%potential_introns, $target, $target_seq);
	# E_S6_rep_c92523

	print "  Aligning and inserting introns (",(scalar(keys %introns)),")...\n";

	# Insert intronic sequence into exon
	foreach my $site (sort { $b <=> $a } keys %introns) {
		print "    Consensing introns at site: $site...\t";

		# Determine which contigs don't have an intron at this site
		my %intronless_seqs = map { ($_ ne $target) ? ($_ => 1) : () } keys %{$final_alignments{$target}};
		foreach my $intron (@{$introns{$site}}) {
			#my $seq = $intron->{SEQ};
			my $seqname = $intron->{SEQNAME};
			delete($intronless_seqs{$seqname});
		}

		# Correct for minor misalignments which can occur with spaln
		foreach my $seq (keys %intronless_seqs) {
			remove_intron_from_exon($site, $seq, $target, \%introns);
		}

		# Align all introns present at this site
		my %aligned;
		if (scalar(@{$introns{$site}}) > 1) {

			# Output introns to fasta file for alignment
			open(my $tmp, ">", "intron-$site.fasta");
			foreach my $intron (@{$introns{$site}}) {
				my $seq = $intron->{SEQ};
				my $seqname = $intron->{SEQNAME};
				print {$tmp} ">$seqname\n";
				print {$tmp} "$seq\n";
			}
			close($tmp);

			# Align with mafft, parse results, and clean up
			#my $return = system("mafft --maxiterate 1000 --localpair intron-$site.fasta > intron-$site.aln.fasta 2> /dev/null");
			my $return = system("$mafft --maxiterate 1000 --localpair --thread $free_cpus intron-$site.fasta > intron-$site.aln.fasta 2> /dev/null");
			#my $return = system("mafft --maxiterate 1000 --localpair intron-$site.fasta > intron-$site.aln.fasta");
			die "Error occured while running mafft: $!.\n" if ($return);
			%aligned = parse_fasta("intron-$site.aln.fasta");
			unlink("intron-$site.aln.fasta");
		}
		else {
			# Only one contig has an intron here, alignment isn't needed
			my $intron = @{$introns{$site}}[0];
			my $seq = $intron->{SEQ};
			my $seqname = $intron->{SEQNAME};
			%aligned = ($seqname => $seq);
		}

		# How many nucleotides are in the final alignment
		my $align_length = length((values %aligned)[0]);
		print "finished intron consensus, length = $align_length.\n";

		# Insert aligned sequence or required number of gaps
		foreach my $seq (keys %{$final_alignments{$target}}) {

			# Intronic sequence identified for this contig
			if (exists($aligned{$seq})) {
				substr($final_alignments{$target}->{$seq}, $site, 0) = $aligned{$seq};	
			}
			# Intronic sequence was not identified for this contig, add gaps
			else {
				substr($final_alignments{$target}->{$seq}, $site, 0) = "-" x $align_length;	
			}
		}
		unlink("intron-$site.fasta");
	}
	print "\n";

	# Output contigs aligned to target sorted by starting index
	open(my $out, ">", "$target.spaln.fasta");
	print {$out} ">$target\n";
	print {$out} "$final_alignments{$target}->{$target}\n";
	foreach my $contig (sort { local $a = $a;
							   local $b = $b;
							   ($a = $final_alignments{$target}->{$a}) =~ s/^(-*).*/$1/;
							   ($b = $final_alignments{$target}->{$b}) =~ s/^(-*).*/$1/;
							   length($a) <=> length($b) } keys %{$final_alignments{$target}}) {
		next if ($contig eq $target);
		print {$out} ">$contig\n";
		print {$out} "$final_alignments{$target}->{$contig}\n";
	}
	close($out);

	#last;
	#print Dumper($final_alignments{$target}),"\n";
	#die;
}

# Create a consensus for each target which can be used for SNP/haplotype calling
my %consensuses = consense_alignments(\%final_alignments);

# Output consensus sequence to fasta
open(my $out, ">", $consensus_output);
foreach my $consensus (keys %consensuses) {
	print {$out} ">$consensus\n";
	print {$out} "$consensuses{$consensus}\n";
}
close($out);

# Output troublesome targets
open($out, ">", "troublesome.txt");
foreach my $target (keys %troublesome) {
	print {$out} "$target\n";
}
close($out);

sub align_contig {
	my $opts = shift;
	my $seq = $opts->{CONTIG_SEQ};
	my $name = $opts->{CONTIG_NAME};
	my $target_seq = $opts->{TARGET_SEQ};
	my $target_name = $opts->{TARGET_NAME};
	my $introns = $opts->{INTRONS};
	my $potential_introns = $opts->{POT_INTRONS};
	my $ignore_introns = $opts->{IGNORE_INTRONS};

	#return if $name eq 'E_S6_rep_c7351';

	# Output contig to file
	open(my $tmp, ">", "$name.fasta");
	print {$tmp} ">$name\n";
	print {$tmp} "$seq\n";
	close($tmp);

	my $contig_length = length($seq);

	# Output reference to file
	open($tmp, ">", "target.fasta");
	print {$tmp} ">$target_name\n";
	print {$tmp} "$target_seq\n";
	close($tmp);

	# For more human readable output 
#	system("$spaln -Q1 -S1 -LS -O4 $name.fasta target.fasta");
#	print "\n\n";
#	system("$spaln -Q1 -S1 -LS -O5 $name.fasta target.fasta");
#	print "\n\n";

	# Align with spaln -08 output is cigar format
	#chomp(my @spaln_out = `$spaln -Q1 -S1 -LS -O8 $name.fasta target.fasta`);
	#chomp(my @spaln_out = `$spaln -Q3 -S1 -LS -O8 $name.fasta target.fasta`);
	#chomp(my @spaln_out = `$spaln -Q3 -S1 -LS -O8 -ya2 $name.fasta target.fasta`);
	#chomp(my @spaln_out = `$spaln -Q3 -S1 -LS -O8 -t40 -ya1 $name.fasta target.fasta`);
	chomp(my @spaln_out = `$spaln -Q3 -S1 -LS -O8 -t$free_cpus -ya2 $name.fasta target.fasta`);
	die "Error occured while aligning with spaln: $!.\n" if ($?);
	#exit(0) if $ignore_introns;
	unlink("$name.fasta");
	unlink("target.fasta");

#	print Dumper(\@spaln_out),"\n";

	my $line = shift(@spaln_out);
	return 0 if (!defined($line));

	# Remove cigar identifier
	$line =~ s/cigar: //;

	my @line = split(/\s+/, $line);

	# Extract general alignment info from cigar
	my ($qid, $qstart, $qend, $qstrand, $tid, $tstart, $tend, $tstrand, $score) = splice(@line, 0, 9);

	# If spaln prefers reverse complement hit (even though -S1 should make only forward hits...)
	if ($tstrand eq '-') {
		$seq = rev_comp($seq);
		$contig_seqs{$name} = $seq;

		$tstrand = "+";
		$tstart = length($seq) - $tstart - 1;
		$tend = length($seq) - $tend - 1;
	}
#	unlink("$name.fasta");
#	unlink("target.fasta");

	my $ref_seq = $targets{$tid};
	my $ref_length = length($ref_seq);

	my $cigar = join("", @line);

	# Check for and remove exons which are too small, assume they are part of the flanking intron
	while ($cigar =~ /N(\d+)M(\d+)N(\d+)/g) {
		if ($2 <= $min_exon_length) {
			print "  $cigar\n";
			my $total_length = $1 + $2 + $3;
			$cigar =~ s/N(\d+)M(\d+)N(\d+)/N$total_length/;
		}
	}

	print "  $qid $qstart $qend $tid $tstart $tend\n";
	print "  $cigar\n\n";

	# Handle potential introns occuring at alignment overhangs
	if ($potential_introns) {
		# Might allow overhangs, especially if $qstart == 0 or $qend == length of reference sequence?
		# Set maximum length, 300 bp? truncate or completely remove?
	
		# Extract unaligned overhangs from start and end of contigs
		my $end_overhang = substr($contig_seqs{$tid}, 0, $tstart);
		my $start_overhang = substr($contig_seqs{$tid}, $tend, length($contig_seqs{$tid}) - $tend);

		# Add end overhang to list of potential introns
		if ($end_overhang && length($end_overhang) >= $min_overhang_length && length($end_overhang) <= $max_overhang_length) {
			push(@{$potential_introns->{ENDS}->{$qstart}}, {SEQNAME => $tid,
												        	REF_START => $qstart,
												        	T_START => 0,
												        	T_END => $tstart,
												        	SEQ => $end_overhang});	
		}
#		elsif ($end_overhang && length($end_overhang) > $max_overhang_length) {
#			substr($end_overhang, length($end_overhang) - $max_overhang_length, $max_overhang_length) = '';
#			push(@{$potential_introns->{ENDS}->{$qstart}}, {SEQNAME => $tid,
#												        	REF_START => $qstart,
#												        	#T_START => 0,
#															T_START => $tstart - $max_overhang_length,
#												        	T_END => $tstart,
#												        	SEQ => $end_overhang});	
#		}
		# Add start overhang to list of potential introns
		if ($start_overhang && length($start_overhang) >= $min_overhang_length && length($start_overhang) <= $max_overhang_length) {
			push(@{$potential_introns->{STARTS}->{$qend}}, {SEQNAME => $tid,
												            REF_START => $qend,
												            T_START => $tend,
												            T_END => length($contig_seqs{$tid}),
												            SEQ => $start_overhang});	
		}
#		elsif ($start_overhang && length($start_overhang) > $max_overhang_length) {
#			substr($start_overhang, $max_overhang_length, length($start_overhang) - $max_overhang_length) = '';
#			push(@{$potential_introns->{STARTS}->{$qend}}, {SEQNAME => $tid,
#												            REF_START => $qend,
#												            T_START => $tend,
#												            T_END => $tend + $max_overhang_length,
#												            SEQ => $start_overhang});	
#		}
	}

	# Add gaps before alignment begins
	$final_alignments{$target_name}->{$tid} .= "-" x ($qstart);

	# Loop through cigar alignment
	my $query_index = 0;
	my $target_index = 0;
	while ($cigar =~ /([A-Z])(\d+)/g) {
		my $type = $1;
		my $length = $2;

		# Deletion is an intron
		if ($type eq "N") {
			if (!$ignore_introns) {
				#print "  seq_length: ",length($seq),", tstart: $tstart, tindex: $target_index, tstart+tindex: ",($tstart + $target_index),", substr_length: $length\n";
				#push(@{$introns->{$qstart + $query_index}}, {SEQNAME => $tid, REF_START => $qstart + $query_index, T_END => $tstart + $target_index + $length,
				push(@{$introns->{$qstart + $query_index}}, {SEQNAME => $tid, REF_START => $qstart + $query_index, T_START => $tstart + $target_index,
															 T_END => $tstart + $target_index + $length, SEQ => substr($seq, $tstart + $target_index, $length)});
			}
			$target_index += $length;
		}
		# Deletion, missing base in reference compared to contig
		elsif ($type eq "D") {
			$target_index += $length;
		}
		# Insertion, extra base in reference compared to contig
		elsif ($type eq "I") {
			$final_alignments{$target_name}->{$tid} .= "-" x $length;
			$query_index += $length;
		}
		# Alignable sequence
		else {
			#print "  seq_length: ",length($seq),", tstart: $tstart, tindex: $target_index, tstart+tindex: ",($tstart + $target_index),", substr_length: $length\n";
			#die if (!defined(substr($seq, $tstart + $target_index, $length)));
			$final_alignments{$target_name}->{$tid} .= substr($seq, $tstart + $target_index, $length);
			$target_index += $length;
			$query_index += $length;
		}
	}
#	print "\n";

	# Add gaps until alignment ends
	$final_alignments{$target_name}->{$tid} .= "-" x (length($target_seq) - $qend);

	return;
}

sub remove_intron_from_exon {
	my ($site, $seqname, $target, $introns) = @_;
	my %introns = %{$introns};

	my $seq = $final_alignments{$target}->{$seqname};

	# Extract sequence before and after intron occurence
	my $pre_intron = substr($seq, 0, $site);
	my $post_intron = substr($seq, $site, length($seq) - $site);

	# Remove gaps from sequences
	(my $pre_intron_ungapped = $pre_intron) =~ s/-//g;
	(my $post_intron_ungapped = $post_intron) =~ s/-//g;

	# Check that the intron actually occurs in a region covered by this sequence
	if ($pre_intron_ungapped && $post_intron_ungapped) {
#		print "$seq\n";
#		
#		print "$seqname\n";
#		print "$pre_intron\n\n";
#		print "$post_intron\n\n";
#
#		print "pre_intron = ",length($pre_intron_ungapped),"\n";
#		print "post_intron = ",length($post_intron_ungapped),"\n";

		# Check length of sequence is under threshold
		if (length($pre_intron_ungapped) <= $min_misaligned_intron_length || length($post_intron_ungapped) <= $min_misaligned_intron_length) {
			
			# Sequence before intron is most likely intron misaligned as exon
			if (length($pre_intron_ungapped) <= $min_misaligned_intron_length) {
#				if (length($pre_intron_ungapped) >= 25) { # TODO: remove magic number
#					push(@{$introns{$site}}, {SEQNAME => $seqname, REF_START => $site, SEQ => $pre_intron_ungapped});
#				}
				$final_alignments{$target}->{$seqname} = "-" x length($pre_intron) . $post_intron;
			}
			# Sequence after intron is most likely intron misaligned as exon
			else {
#				if (length($post_intron_ungapped) >= 25) {
#					push(@{$introns{$site}}, {SEQNAME => $seqname, REF_START => $site, SEQ => $post_intron_ungapped});
#				}
				$final_alignments{$target}->{$seqname} = $pre_intron . "-" x length($post_intron);
			}
		}
	}
	return;
}

sub insert_potential_introns {
	#my ($potential_introns, $target, $target_seq) = @_;
	my ($introns, $potential_introns, $target, $target_seq) = @_;

	# Extract potential intron ends
	my %ends = %{$potential_introns->{ENDS}};
	my @end_sites = sort { $a <=> $b } keys %ends;

	# Extract potential intron starts
	my %starts = %{$potential_introns->{STARTS}};
	my @start_sites = sort { $a <=> $b } keys %starts;

	# Join locations of potential introns
	my @all_sites = sort { $a <=> $b } (@end_sites, @start_sites);

	# Stores what's already been clustered
	my %clusters;
	my %in_cluster;
	foreach my $index (0 .. $#all_sites - 1) {

		my $site1 = $all_sites[$index];
		next if ($in_cluster{$site1});
		foreach my $index2 ($index + 1 .. $#all_sites) {

			my $site2 = $all_sites[$index2];
			if ($site2 - $site1 <= $min_overhang_length_discrepancy) {
				if (!exists($in_cluster{$site1})) {
					push(@{$clusters{$site1}}, $site2);
					$in_cluster{$site2} = $site1;
				}
				else {
					push(@{$clusters{$in_cluster{$site1}}}, $site2);
					$in_cluster{$site2} = $site1;
				}
			}
			else {
				last;
			}
		}
	}
#	print Dumper(\%clusters),"\n";
#	print Dumper(\%ends),"\n";
#	print Dumper(\%starts),"\n";
#	die;

	# Remove clusters which cluster to a spanned intron, add sequences to that intron
	CLUSTER: foreach my $cluster (keys %clusters) {
		unshift(@{$clusters{$cluster}}, $cluster);
			
		# Iterate through each spanned intron location
		foreach my $spanned_intron_site (keys %{$introns}) {

			# Check each site in cluster against known intron site
			foreach my $incomplete_intron_site (@{$clusters{$cluster}}) {

				# Check if cluster and intron fall within minimum distance required for joining
				if (abs($incomplete_intron_site - $spanned_intron_site) <= $min_exon_length) {

					# Adding partials to spanned introns, lot of work to get right, not much benefit
					# Add each partial sequence to the complete intron
#					foreach my $site (@{$clusters{$cluster}}) {
#						#print Dumper($introns->{$spanned_intron_site}),"\n";
#						foreach my $end (@{$ends{$site}}) {
#							push(@{$introns->{$spanned_intron_site}}, $end);
#						}
#						foreach my $start (@{$starts{$site}}) {
#							push(@{$introns->{$spanned_intron_site}}, $start);
#						}
#						print Dumper($introns->{$spanned_intron_site}),"\n";
#						#die;
#					}
					
					# Remove this cluster
					#splice(@{$clusters{$cluster}}, $index, 1);
					delete($clusters{$cluster});
					next CLUSTER;
				}
			}
		}
	}
	print "  Aligning and inserting unspanned introns (",(scalar(keys %clusters)),")...\n";

#	print Dumper($ends{1186}),"\n";
#	print Dumper($starts{1186}),"\n";
#	die;
	
	# Iterate through each cluster
	my %cluster_lengths;
	foreach my $cluster (sort { $b <=> $a } keys %clusters) {
	#foreach my $cluster (sort { $a <=> $b } keys %clusters) {
		#my $cluster = 1186;

		my $cluster_id = join("-", @{$clusters{$cluster}});

		# Check that this cluster contains both the start and end of this intron
		my $has_end;
		my $has_start;
		foreach my $site (@{$clusters{$cluster}}) {
			$has_end++ if (exists($ends{$site}));
			$has_start++ if (exists($starts{$site}));
		}

		# Only do something if we have the start and end of this intron
		if ($has_start && $has_end) {

			#print "    Inserting intron near $cluster...\n";
			print "    Inserting partial intron near site: $cluster...\t";

			my $min_end;
			my $max_start = 0;

			# Store starts/ends of particular contigs
			my %contigs;

			# Outputting ending sequences of intron
			my %sites; # TODO: get rid of reliance on this, cluster should really be a hash of hashes
			my $end_count = 0;
			open(my $tmp, ">", "intron-$cluster_id-ends.fasta");
			foreach my $site (@{$clusters{$cluster}}) {
				next if ($sites{$site});

				# Output intron ends
				if (exists($ends{$site})) {
					foreach my $intron (@{$ends{$site}}) {
						my $seq = $intron->{SEQ};
						my $seqname = $intron->{SEQNAME};
						print {$tmp} ">$seqname\n";
						print {$tmp} "$seq\n";
						$contigs{$seqname} = $site;
						$end_count++;
						$min_end = $site if (!defined($min_end) || $site < $min_end);
						$sites{$site}++;
					}
				}
			}
			close($tmp);
			undef(%sites);

			# Align sequences if needed
			my %aligned_ends;
			if ($end_count > 1) {
				# Align with mafft, parse results, and clean up
				my $return = system("$mafft --maxiterate 1000 --localpair --thread $free_cpus intron-$cluster_id-ends.fasta > intron-$cluster_id-ends.aln.fasta 2> /dev/null");
				die "Error occured while running mafft: $!.\n" if ($return);
				%aligned_ends = parse_fasta("intron-$cluster_id-ends.aln.fasta");
			}
			else {
				%aligned_ends = parse_fasta("intron-$cluster_id-ends.fasta");
			}
			unlink("intron-$cluster_id-ends.fasta");
#			unlink("intron-$cluster_id-ends.aln.fasta");
			
			# Outputting starting sequences of intron
			my $start_count = 0;
			open($tmp, ">", "intron-$cluster_id-starts.fasta");
			foreach my $site (@{$clusters{$cluster}}) {
				next if ($sites{$site});

				# Output intron starts
				if (exists($starts{$site})) {
					foreach my $intron (@{$starts{$site}}) {
						my $seq = $intron->{SEQ};
						my $seqname = $intron->{SEQNAME};
						print {$tmp} ">$seqname\n";
						print {$tmp} "$seq\n";
						$contigs{$seqname} = $site;
						$start_count++;
						$max_start = $site if ($site > $max_start);
						$sites{$site}++;
					}
				}
			}
			close($tmp);

			# Align sequences if needed
			my %aligned_starts;
			if ($start_count > 1) {
				# Align with mafft, parse results, and clean up
				$return = system("$mafft --maxiterate 1000 --localpair --thread $free_cpus intron-$cluster_id-starts.fasta > intron-$cluster_id-starts.aln.fasta 2> /dev/null");
				die "Error occured while running mafft: $!.\n" if ($return);
				%aligned_starts = parse_fasta("intron-$cluster_id-starts.aln.fasta");
			}
			else {
				%aligned_starts = parse_fasta("intron-$cluster_id-starts.fasta");
			}
			unlink("intron-$cluster_id-starts.fasta");
#			unlink("intron-$cluster_id-starts.aln.fasta");

			# Append N's to indicate the intron isn't bridged?

			# cap3 to join?

			# Determine lengths of start and end alignments
			my $aligned_end_length = length((values %aligned_ends)[0]);
			my $aligned_start_length = length((values %aligned_starts)[0]);

#			print Dumper(\%aligned_starts),"\n";
#			print Dumper(\%contigs),"\n";
#			print "min_end: $min_end\n";
#			print "max_start: $max_start\n";
			#die;

			#$cluster_lengths{$cluster} = $aligned_end_length + $aligned_start_length;

			# Determine maximum offset, used to pad insert with correct number of gaps
			my $max_offset = 0;
			foreach my $seq (keys %contigs) {
				if ($max_start - $contigs{$seq} > $max_offset) {
					$max_offset = $max_start - $contigs{$seq};
				}
			}

			# So we can correct spanned intron indices
			#$cluster_lengths{$cluster} = $aligned_end_length + $aligned_start_length;
			$cluster_lengths{$cluster} = $aligned_end_length + $aligned_start_length + $max_offset;
			
			# Insert aligned intron ends into alignment
			foreach my $seq (keys %{$final_alignments{$target}}) {
				#next if (exists($aligned_starts{$seq}));

				# Intronic sequence identified for this contig
				if (exists($aligned_ends{$seq})) {
					#print "inserting end at $contigs{$seq}...\n";
					#substr($final_alignments{$target}->{$seq}, $contigs{$seq}, 0) = $aligned_ends{$seq};	
					
					my $offset = $max_start - $contigs{$seq};
					my $misaligned = substr($final_alignments{$target}->{$seq}, $max_start - $offset, $offset);
					substr($final_alignments{$target}->{$seq}, $max_start - $offset, $offset) = '-' x $offset;
					substr($final_alignments{$target}->{$seq}, $max_start, 0) = "-" x ($max_offset - length($misaligned)).$aligned_ends{$seq}.$misaligned;
					#print $misaligned,"\n";

					#die;
				}
				# Intronic sequence was not identified for this contig, add gaps
				else {
					substr($final_alignments{$target}->{$seq}, $max_start, 0) = "-" x ($aligned_end_length + $max_offset);
				}
			}

			# Insert aligned intron starts into alignment
			foreach my $seq (keys %{$final_alignments{$target}}) {
				#next if (exists($aligned_ends{$seq}));

				# Intronic sequence identified for this contig
				if (exists($aligned_starts{$seq})) {
					#print "inserting start at $contigs{$seq}...\n";
					substr($final_alignments{$target}->{$seq}, $contigs{$seq}, 0) = $aligned_starts{$seq};
				}
				# Intronic sequence was not identified for this contig, add gaps
				else {
					substr($final_alignments{$target}->{$seq}, $max_start, 0) = "-" x $aligned_start_length;	
				}
			}
#			foreach my $seq (keys %{$final_alignments{$target}}) {
#				if (exists($aligned_starts{$seq})) {
#					print "$seq: ",length($final_alignments{$target}->{$seq})," (start)\n";
#				}
#				elsif (exists($aligned_ends{$seq})) {
#					print "$seq: ",length($final_alignments{$target}->{$seq})," (end)\n";
#				}
#				else {
#					print "$seq: ",length($final_alignments{$target}->{$seq}),"\n";
#				}
#			}
			print "finished intron insertion, length of inserted sequence = ",($aligned_start_length + $aligned_end_length + $max_offset),".\n";
			#die;
		}
		else {
			print "  $cluster == cluster? more like laCkLUSTER\n";
		}
	}

	# Correct intron indices being off now
	print "\n  Updating indices...\n";
	foreach my $site (sort { $b <=> $a } keys %{$introns}) {
		my $new_index = $site;
		foreach my $cluster (sort { $a <=> $b } keys %clusters) {
			if ($site > $cluster) {
				$new_index += $cluster_lengths{$cluster};
			}
		}
		$introns->{$new_index} = delete($introns->{$site});
		print "    Intron at $site is now at $new_index.\n";
	}
	print "\n";
	
	#die;

	# Special cases for end at 0 and length of target sequence

	return;
}

sub move_misaligned_introns {
	my ($introns, $target, $target_seq) = @_;

	# Determine number of contigs which contain each intron
	my %counts;
	foreach my $site (keys %{$introns}) {
		foreach my $intron (@{$introns->{$site}}){
			$counts{$site}++;
		}
	}

	# Cluster contigs based on distance
	my %clusters;
	my %in_cluster;
	my @sites = sort { $a <=> $b } keys %{$introns};
	foreach my $index (0 .. $#sites - 1) {

		my $site1 = $sites[$index];
		next if ($in_cluster{$site1});
		foreach my $index2 ($index + 1 .. $#sites) {

			my $site2 = $sites[$index2];

			if ($site2 - $site1 <= $min_exon_length) {
				if (!exists($in_cluster{$site1})) {
					push(@{$clusters{$site1}}, $site2);
					$in_cluster{$site2} = $site1;
				}
				else {
					push(@{$clusters{$in_cluster{$site1}}}, $site2);
					$in_cluster{$site2} = $site1;
				}
			}
			else {
				last;
			}
		}
	}
	#print Dumper(\%counts),"\n";
	#print Dumper(\%clusters),"\n";

	# Move introns which occur too closely to the site with the highest frequency
	foreach my $cluster (keys %clusters) {
		unshift(@{$clusters{$cluster}}, $cluster);

		my $most_frequent;
		my $highest_frequency = 0;
		foreach my $site (@{$clusters{$cluster}}) {
			print "$site\n";
			if ($counts{$site} > $highest_frequency) {
				$highest_frequency = $counts{$site};
				$most_frequent = $site;
			}
		}
		print "most frequent for cluster $cluster: $most_frequent ($highest_frequency)\n";

		# Set cluster id to most frequently occuring site
		if ($most_frequent != $cluster) {
			$clusters{$most_frequent} = delete($clusters{$cluster});
		}
	}
#	print "clusters:\n";
#	print Dumper(\%clusters),"\n";
#	print Dumper(\%counts),"\n";

	my %realign;
	# Move introns from cluster to correct site
	#foreach my $cluster (keys %clusters) {
	foreach my $cluster (sort { $b <=> $a } keys %clusters) {
		$troublesome{$target}++;
		print "\nIntron(s) occurred too closely to site $cluster\n";

		#foreach my $site (reverse(@{$clusters{$cluster}})) {
		foreach my $site (@{$clusters{$cluster}}) {
			#last if ($site == $cluster);
			next if ($site == $cluster);

			print "  moving introns at $site...\n";

			foreach my $intron (@{$introns->{$site}}) {
				#print Dumper(\$intron),"\n";

				my $diff = $site - $cluster;
				my $t_start = $intron->{T_START};
				my $t_end = $intron->{T_END};
				my $seqname = $intron->{SEQNAME};

				# Add sequence to realignment hash
				if (!exists($realign{$seqname})) {
					$realign{$seqname} = $contig_seqs{$seqname};
				}

				# Moving intron forwards
				if ($diff < 0) {
					my $misaligned_tail = substr($contig_seqs{$seqname}, $t_start, -1 * $diff);

					# Remove misaligned sequence from intron
					$intron->{SEQ} =~ s/^\Q$misaligned_tail\E//;
				}
				# Moving intron backwards
				else {
					my $misaligned_tail = substr($contig_seqs{$seqname}, $t_start - $diff, $diff);

					# Append misaligned sequence which occurred between the two sites to beginning
					$intron->{SEQ} = $misaligned_tail.$intron->{SEQ};
				}

				# Correct intron's start indices
				$intron->{T_START} -= $diff;
				$intron->{REF_START} -= $diff;

				# Move this intron to its proper location
				push(@{$introns->{$cluster}}, $intron);

#				# Remove intron from sequence in realignment hash
#				substr($realign{$seqname}, $intron->{T_START}, $intron->{T_END} - $intron->{T_START}) = '';
			}
			delete($introns->{$site});
		}
	}

	# Delete all introns from sequences we are realigning to minimize chance of misalignment
	foreach my $site (sort { $b <=> $a } keys %{$introns}) {
		foreach my $intron (@{$introns->{$site}}) {
			my $seqname = $intron->{SEQNAME};
			if (exists($realign{$seqname})) {
				substr($realign{$seqname}, $intron->{T_START}, $intron->{T_END} - $intron->{T_START}) = '';
			}
		}
	}

	# Realign exons of misaligned sequences
	foreach my $seqname (keys %realign) {
		my $seq = $realign{$seqname};

		# Delete incorrect alignment we currently have
		delete($final_alignments{$target}->{$seqname});

		# Realign exonic sequence after alignment error
		# TODO: add large penalty to prevent additional introns?
		print "  Realigning exon...\n";
		align_contig({CONTIG_NAME => $seqname, CONTIG_SEQ => $seq, TARGET_NAME => $target, TARGET_SEQ => $target_seq, IGNORE_INTRONS => 1});
	}

	return;
}

sub check_path_for_exec {
	my ($exec, $continue) = @_;
	
	my $path = $ENV{PATH}.":."; # include current directory as well
	my @path_dirs = split(":", $path);

	my $exec_path;
	foreach my $dir (@path_dirs) {
		$dir .= "/" if ($dir !~ /\/$/);
		$exec_path = $dir.$exec if (-e $dir.$exec && -x $dir.$exec && !-d $dir.$exec);
	}

	die "Could not locate: '$exec'. This script requires this program in your path.\n" if (!defined($exec_path) && !defined($continue));
	return $exec_path;
}

sub parse_fasta {
	my $filename = shift;

	my $taxon;
	my %align;
	open(my $alignment_file, '<', $filename) 
		or die "Could not open '$filename': $!\n";

	while (my $line = <$alignment_file>) {
		$line =~ s/^\s+|\s+$//g;

		# Taxon name
		if ($line =~ /^>(\S+)/) {
			$taxon = $1;
		}
		else {
			# Taxon sequence
			$taxon =~ s/-/_/g;
			$align{$taxon} .= uc($line);
		}
	}
	close($alignment_file);
	
	return %align;
}

sub rev_comp {
	my $seq = shift;
	
	my %comp = ('A' => 'T', 'T' => 'A', 'C' => 'G', 'G' => 'C');

	my $rev_comp;
	my $rev = reverse($seq);
	foreach my $index (0 .. length($rev) - 1) {
		my $char = substr($rev, $index, 1);

		if (exists($comp{$char})) {
			$rev_comp .= $comp{$char};
		}
		else {
			$rev_comp .= 'N';
		}
	}

	return $rev_comp;
}

sub consense_alignments {
	my $alignment = shift;

	my %consensuses;
	foreach my $target (keys %{$alignment}) {
		my %target_alignment = %{$alignment->{$target}};

		# Determine length of alignment
		my $align_length = length((values %target_alignment)[0]);

		# Loop through each site in alignment
		foreach my $index (0 .. $align_length - 1) {

			# Loop through each sequence in alignment
			my %site = ('A' => 0, 'T', => 0, 'C' => 0, 'G' => 0);
			foreach my $sequence (values %target_alignment) {
				my $char = substr($sequence, $index, 1);
				die "$target\n" if (!defined($char));
				$site{$char}++;
			}
			
			# Calculate and append consensus base
			my $consensus = consense_site(\%site);
			$consensuses{$target} .= $consensus;
		}
	}

	return %consensuses;
}

sub consense_site {
	my $site = shift;

	# Sort bases by descending order of frequency
	my @sorted_bases = sort { $site->{$b} <=> $site->{$a} } keys %{$site};

	# Return most frequent unambiguous base if possible
	foreach my $base (@sorted_bases) {
		if ($base =~ /[ACTG]/) {
			return $base;
		}
	}

	# Return most frequent ambiguity code otherwise
	foreach my $base (@sorted_bases) {
		if ($base =~ /[A-Z]/) {
			return $base;
		}
	}

	# Should never happen
	die "Error consensing site:\n",Dumper($site),"\n";
}

sub get_free_cpus {

	my $os_name = $^O;

	# Returns a two-member array containing CPU usage observed by top,
	# top is run twice as its first output is usually inaccurate
	my @percent_free_cpu;
	if ($os_name eq "darwin") {
		# Mac OS
		chomp(@percent_free_cpu = `top -i 1 -l 2 | grep "CPU usage"`);
	}
	else {
		# Linux
		chomp(@percent_free_cpu = `top -bn2d0.05 | grep "Cpu(s)"`);
	}

	my $percent_free_cpu = pop(@percent_free_cpu);

	if ($os_name eq "darwin") {
		# Mac OS
		$percent_free_cpu =~ s/.*?(\d+\.\d+)%\s+id.*/$1/;
	}
	else {
		# linux 
		$percent_free_cpu =~ s/.*?(\d+\.\d)\s*%?ni,\s*(\d+\.\d)\s*%?id.*/$1 + $2/; # also includes %nice as free 
		$percent_free_cpu = eval($percent_free_cpu);
	}

	my $total_cpus;
	if ($os_name eq "darwin") {
		# Mac OS
		$total_cpus = `sysctl -n hw.ncpu`;
	}
	else {
		# linux
		$total_cpus = `grep --count 'cpu' /proc/stat` - 1;
	}

	my $free_cpus = ceil($total_cpus * $percent_free_cpu / 100);

	if ($free_cpus == 0 || $free_cpus !~ /^\d+$/) {
		$free_cpus = 1; # assume that at least one cpu can be used
	}
	
	return $free_cpus;
}
