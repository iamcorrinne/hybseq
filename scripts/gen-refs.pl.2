#!/usr/bin/perl
use strict;
use warnings;
use POSIX;
use Data::Dumper;
use Getopt::Long;
use Time::HiRes qw(usleep);
use Fcntl qw(:flock SEEK_END);

my $min_misaligned_intron_length = 100;

#my $free_cpus = get_free_cpus();

# Check that required executables are in path
my $blat = check_path_for_exec("blat");
my $spaln = check_path_for_exec("spaln");

# Parse command line invocation
my $targets;
GetOptions(
	't|targets=s' => \$targets,
);

my $input = shift;

# Input error checking
die "You must specify an assembly as input.\n" if (!defined($input));
die "You must specify a fasta file containing target sequences (-t).\n" if (!defined($targets));
die "You must you have specified an incorrect argument.\n" if (@ARGV);

# Output file names
my $blat_out_name = $input.".psl";
(my $consensus_output = $input) =~ s/\.fa(sta)?/.con.fasta/i;

# Run preliminary blat to determine which targets and contigs have alignable sequence
print "Running blat against targets and contigs...\n";
#my $return = system("$blat $input $targets -t=dna -q=dna -noHead -fine -repMatch=1000000 $blat_out_name");
my $return = system("$blat $input $targets -t=dna -q=dna -noHead -repMatch=1000000 $blat_out_name") if (!-e $blat_out_name);
die "Error running blat: '$return'.\n" if ($return);

# Parse blat output
my %targets;
open(my $blat_out, "<", $blat_out_name);
while (my $line = <$blat_out>) {
	chomp($line);

	my @line = split(/\s+/, $line);

	# Blat headers
	my ($match, $mismatch, $rep_matches, $n_count, $q_num_inserts, $q_base_inserts, 
	    $t_num_inserts, $t_base_inserts, $strand, $q_name, $q_size, $q_start, $q_end,
		$t_name, $t_size, $t_start, $t_end, $block_count, $block_sizes, $q_starts, $t_starts) = @line; 

	# Check that contig meets target coverage threshold
#	if (($match + $mismatch) / $q_size >= $target_perc_cov_threshold && 
#		($match + $mismatch) / $q_size >= $contig_perc_cov_threshold) {

		# If we have multiple hits for the same contig and target sequence, we opt for the longer
		if (!exists($targets{$q_name}->{$t_name})) {
			#$targets{$q_name}->{$t_name} = {'NAME' => $t_name, 'STRAND' => $strand, 'T_STARTS' => $t_starts, 'Q_STARTS' => $q_starts, 'SIZES' => $block_sizes};
			$targets{$q_name}->{$t_name} = {'NAME' => $t_name, 'STRAND' => $strand, 'SIZES' => $block_sizes};
		}
		else {
			my $hit = $targets{$q_name}->{$t_name};

			# Calculate how long the currently stored hit is
#			my $current_size = $hit->{SIZES};
#			my @current_size = split(",", $current_size);
#
#			$current_size = 0;
#			foreach my $size (@current_size) {
#				$current_size += $size;
#			}
			my $current_size = 0;
			$current_size += $_ foreach (split(",", $current_size));

			# Calculate how long the newly identified hit is
#			my $new_size = $block_sizes;
#			my @new_size = split(",", $new_size);
#
#			$new_size = 0;
#			foreach my $size (@new_size) {
#				$new_size += $size;
#			}
			my $new_size = 0;
			$new_size += $_ foreach (split(",", $new_size));

			if ($current_size > $new_size) {
				#$targets{$q_name}->{$t_name} = {'NAME' => $t_name, 'STRAND' => $strand, 'T_STARTS' => $t_starts, 'Q_STARTS' => $q_starts, 'SIZES' => $block_sizes};
				$targets{$q_name}->{$t_name} = {'NAME' => $t_name, 'STRAND' => $strand, 'SIZES' => $block_sizes};
			}
		}
#	}
}
close($blat_out);

# Load contig and target sequences
my %contig_seqs = parse_fasta($input);
my %target_seqs = parse_fasta($targets);

# Create consensus sequence for each target
my %final_alignments;
foreach my $target (keys %targets) {
	my @hits = values %{$targets{$target}};
	my $target_seq = $target_seqs{$target};

	# Stores locations and sequences of introns
	my %introns;
	$final_alignments{$target}->{$target} = $target_seq;

	# Use spaln to align exons of each contig with the reference and identify introns
	foreach my $hit (@hits) {
		my $seqname = $hit->{'NAME'};
		my $seq = $contig_seqs{$seqname};

		# Reverse complement the hit if required
		$seq = rev_comp($seq) if ($hit->{'STRAND'} eq "-");
		#	print "    Contig will be reverse complemented (- hit).\n\n";
		#	foreach my $index (0 .. $#t_starts) {
		#		$t_starts[$index] = $contig_length - $sizes[$index] - $t_starts[$index];
		#		$q_starts[$index] = $target_length - $sizes[$index] - $q_starts[$index];
		#	}
		#	@sizes = reverse(@sizes);
		#	@t_starts = reverse(@t_starts);
		#	@q_starts = reverse(@q_starts);
		#}
		
		#align_contig({CONTIG_NAME => $seqname, CONTIG_SEQ => $seq, TARGET_NAME => $target, TARGET_SEQ => $aligned_contigs{$target}});
		#align_contig({CONTIG_NAME => $seqname, CONTIG_SEQ => $seq, TARGET_NAME => $target, TARGET_SEQ => $aligned_contigs{$target}});
		#align_contig({CONTIG_NAME => $seqname, CONTIG_SEQ => $seq, TARGET_NAME => $target, TARGET_SEQ => $aligned_contigs{$target}, INTRONS => \%introns});
		align_contig({CONTIG_NAME => $seqname, CONTIG_SEQ => $seq, TARGET_NAME => $target, TARGET_SEQ => $target_seq, INTRONS => \%introns});
	}

	# Insert intronic sequence into exon
	foreach my $site (sort { $b <=> $a } keys %introns) {
		print "Consensing introns at site: $site...\n";

		# Determine which contigs don't have an intron at this site
		my %intronless_seqs = map { ($_ ne $target) ? ($_ => 1) : () } keys %{$final_alignments{$target}};
		foreach my $intron (@{$introns{$site}}) {
			#my $seq = $intron->{SEQ};
			my $seqname = $intron->{SEQNAME};
			delete($intronless_seqs{$seqname});
		}

		# Correct for minor misalignments which can occur with spaln
		foreach my $seq (keys %intronless_seqs) {
			remove_intron_from_exon($site, $seq, $target, \%introns);
		}

		# Align all introns present at this site
		my %aligned;
		if (scalar(@{$introns{$site}}) > 1) {

			# Output introns to fasta file for alignment
			open(my $tmp, ">", "intron-$site.fasta");
			foreach my $intron (@{$introns{$site}}) {
				my $seq = $intron->{SEQ};
				my $seqname = $intron->{SEQNAME};
				print {$tmp} ">$seqname\n";
				print {$tmp} "$seq\n";
			}
			close($tmp);

			# Align with mafft, parse results, and clean up
			system("mafft --maxiterate 1000 --localpair intron-$site.fasta > intron-$site.aln.fasta 2> /dev/null");
			%aligned = parse_fasta("intron-$site.aln.fasta");
			unlink("intron-$site.aln.fasta");
		}
		else {
		#	foreach my $intron (@{$introns{$site}}) {
		#		my $seq = $intron->{SEQ};
		#		my $seqname = $intron->{SEQNAME};
		#		%aligned = ($seqname => $seq);
		#	}
			# Only one contig has an intron here, alignment isn't needed
			my $intron = @{$introns{$site}}[0];
			my $seq = $intron->{SEQ};
			my $seqname = $intron->{SEQNAME};
			%aligned = ($seqname => $seq);
		}

		# How many nucleotides are in the final alignment
		my $align_length = length((values %aligned)[0]);

		# Insert aligned sequence or required number of gaps
		foreach my $seq (keys %{$final_alignments{$target}}) {

			# Intronic sequence identified for this contig
			if (exists($aligned{$seq})) {
				substr($final_alignments{$target}->{$seq}, $site, 0) = $aligned{$seq};	
			}
			# Intronic sequence was not identified for this contig, add gaps
			else {
				substr($final_alignments{$target}->{$seq}, $site, 0) = "-" x $align_length;	
			}
		}
		unlink("intron-$site.fasta");
	}

	# Output contigs aligned to target sorted by starting index
	open(my $out, ">", "$target.spaln.fasta");
	print {$out} ">$target\n";
	print {$out} "$final_alignments{$target}->{$target}\n";
	foreach my $contig (sort { local $a = $a;
							   local $b = $b;
							   ($a = $final_alignments{$target}->{$a}) =~ s/^(-*).*/$1/;
							   ($b = $final_alignments{$target}->{$b}) =~ s/^(-*).*/$1/;
							   length($a) <=> length($b) } keys %{$final_alignments{$target}}) {
		next if ($contig eq $target);
		print {$out} ">$contig\n";
		print {$out} "$final_alignments{$target}->{$contig}\n";
	}
	close($out);
	
	#print Dumper($final_alignments{$target}),"\n";
	die;
}

sub align_contig {
	my $opts = shift;
	my $seq = $opts->{CONTIG_SEQ};
	my $name = $opts->{CONTIG_NAME};
	my $target_seq = $opts->{TARGET_SEQ};
	my $target_name = $opts->{TARGET_NAME};
	my $introns = $opts->{INTRONS};

	# Output contig to file
	open(my $tmp, ">", "$name.fasta");
	print {$tmp} ">$name\n";
	print {$tmp} "$seq\n";
	close($tmp);

	# Output reference to file
	open($tmp, ">", "target.fasta");
	print {$tmp} ">$target_name\n";
	print {$tmp} "$target_seq\n";
	close($tmp);

#	system("$spaln -Q1 -S4 -LS -O4 $name.fasta target.fasta");
#	print "\n\n";
#	system("$spaln -Q1 -S4 -LS -O5 $name.fasta target.fasta");
#	print "\n\n";
	# Align with spaln -08 output is cigar format
	chomp(my @spaln_out = `$spaln -Q1 -S4 -LS -O8 $name.fasta target.fasta`);
	die "Error occured while aligning with spaln: $!.\n" if ($?);
	unlink("$name.fasta");
	unlink("target.fasta");

	my $line = shift(@spaln_out);
	return 0 if (!defined($line));

	$line =~ s/cigar: //;

	my @line = split(/\s+/, $line);

	# Extract general alignment info from cigar
	my ($qid, $qstart, $qend, $qstrand, $tid, $tstart, $tend, $tstrand, $score) = splice(@line, 0, 9);

	my $ref_seq = $targets{$tid};
	my $ref_length = length($ref_seq);

	my $cigar = join("", @line);
	print "$qid $qstart $qend $tid $tstart $tend\n";
	print "$cigar\n";
	#die;
	
#	my $end_overhang = substr($assembly{$tid}, 0, $tstart);
#	my $start_overhang = substr($assembly{$tid}, $tend, length($assembly{$tid}) - $tend);

	#$aligned_contigs{$tid} .= "-" x ($qstart);
	$final_alignments{$target_name}->{$tid} .= "-" x ($qstart);

	my $query_index = 0;
	my $target_index = 0;
	while ($cigar =~ /([A-Z])(\d+)/g) {
		my $type = $1;
		my $length = $2;

		# Deletion is an intron
		if ($type eq "N") {
		#	push(@{$introns{$qstart + $query_index}}, {SEQNAME => $tid, REF_START => $qstart + $query_index, 
		#					                           SEQ => substr($assembly{$tid}, $tstart + $target_index, $length)});
			#push(@{$introns{$qstart + $query_index}}, {SEQNAME => $tid, REF_START => $qstart + $query_index, 
			push(@{$introns->{$qstart + $query_index}}, {SEQNAME => $tid, REF_START => $qstart + $query_index, 
							                           SEQ => substr($seq, $tstart + $target_index, $length)});
			$target_index += $length;
		}
		# Insertion is an extra base in reference
		elsif ($type eq "I") {
			#$aligned_contigs{$tid} .= "-" x $length;
			$final_alignments{$target_name}->{$tid} .= "-" x $length;
			$query_index += $length;
		}
		else {
			#$aligned_contigs{$tid} .= substr($assembly{$tid}, $tstart + $target_index, $length);
			#$aligned_contigs{$tid} .= substr($seq, $tstart + $target_index, $length);
			$final_alignments{$target_name}->{$tid} .= substr($seq, $tstart + $target_index, $length);
			$target_index += $length;
			$query_index += $length;
		}
	}
	#$aligned_contigs{$tid} .= "-" x (length($target_seq) - $qend);
	$final_alignments{$target_name}->{$tid} .= "-" x (length($target_seq) - $qend);

	return;
}

sub remove_intron_from_exon {
	#my ($site, $seqname) = @_;
	#my ($site, $seqname, $introns) = @_;
	my ($site, $seqname, $target, $introns) = @_;
	my %introns = %{$introns};

	#my $seq = $aligned_contigs{$seqname};
	my $seq = $final_alignments{$target}->{$seqname};

	# Extract sequence before and after intron occurence
	my $pre_intron = substr($seq, 0, $site);
	my $post_intron = substr($seq, $site, length($seq) - $site);

	# Remove gaps
	(my $pre_intron_ungapped = $pre_intron) =~ s/-//g;
	(my $post_intron_ungapped = $post_intron) =~ s/-//g;

	# Check that the intron actually occurs in a region covered by this sequence
	if ($pre_intron_ungapped && $post_intron_ungapped) {
#		print "$seq\n";
#		
#		print "$seqname\n";
#		print "$pre_intron\n\n";
#		print "$post_intron\n\n";
#
#		print "pre_intron = ",length($pre_intron_ungapped),"\n";
#		print "post_intron = ",length($post_intron_ungapped),"\n";

		# Check length of sequence
		if (length($pre_intron_ungapped) <= $min_misaligned_intron_length || length($post_intron_ungapped) <= $min_misaligned_intron_length) {
			
			# Sequence before intron is most likely intron misaligned as exon
			if (length($pre_intron_ungapped) <= $min_misaligned_intron_length) {
				if (length($pre_intron_ungapped) >= 25) {
					push(@{$introns{$site}}, {SEQNAME => $seqname, REF_START => $site, SEQ => $pre_intron_ungapped});
				}
				#push(@{$introns{$site}}, {SEQNAME => $seqname, REF_START => $site, SEQ => $pre_intron_ungapped});
				#print $aligned_contigs{$seqname},"\n";
				#$aligned_contigs{$seqname} = "-" x length($pre_intron) . $post_intron;
				$final_alignments{$target}->{$seqname} = "-" x length($pre_intron) . $post_intron;
				#print $aligned_contigs{$seqname},"\n";
				#print Dumper($introns{$site}),"\n";
			}
			# Sequence after intron is most likely intron misaligned as exon
			else {
				if (length($post_intron_ungapped) >= 25) {
					push(@{$introns{$site}}, {SEQNAME => $seqname, REF_START => $site, SEQ => $post_intron_ungapped});
				}
				#push(@{$introns{$site}}, {SEQNAME => $seqname, REF_START => $site, SEQ => $post_intron_ungapped});
				#$aligned_contigs{$seqname} = $pre_intron . "-" x length($post_intron);
				$final_alignments{$target}->{$seqname} = $pre_intron . "-" x length($post_intron);
			}
		}
	}
	return;
}

sub check_path_for_exec {
	my ($exec, $continue) = @_;
	
	my $path = $ENV{PATH}.":."; # include current directory as well
	my @path_dirs = split(":", $path);

	my $exec_path;
	foreach my $dir (@path_dirs) {
		$dir .= "/" if ($dir !~ /\/$/);
		$exec_path = $dir.$exec if (-e $dir.$exec && -x $dir.$exec && !-d $dir.$exec);
	}

	die "Could not locate: '$exec'. This script requires this program in your path.\n" if (!defined($exec_path) && !defined($continue));
	return $exec_path;
}

sub parse_fasta {
	my $filename = shift;

	my $taxon;
	my %align;
	open(my $alignment_file, '<', $filename) 
		or die "Could not open '$filename': $!\n";

	while (my $line = <$alignment_file>) {
		$line =~ s/^\s+|\s+$//g;

		# Taxon name
		#if ($line =~ /^>(.*)/) {
		if ($line =~ /^>(\S+)/) {
			$taxon = $1;
		}
		else {
			# Taxon sequence
			$taxon =~ s/-/_/g;
			$align{$taxon} .= uc($line);
		}
	}
	close($alignment_file);
	
	return %align;
}

sub rev_comp {
	my $seq = shift;
	
	my %comp = ('A' => 'T', 'T' => 'A', 'C' => 'G', 'G' => 'C');

	my $rev_comp;
	my $rev = reverse($seq);
	foreach my $index (0 .. length($rev) - 1) {
		my $char = substr($rev, $index, 1);
		#$rev_comp .= $comp{$char};
		if (exists($comp{$char})) {
			$rev_comp .= $comp{$char};
		}
		else {
			$rev_comp .= 'N';
		}
	}

	return $rev_comp;
}

sub consense_alignments {
	my $alignment = shift;

	my %consensuses;

	return;
}
